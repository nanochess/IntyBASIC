>>>>>>>>>>>>>  Manual del usuario de IntyBASIC  <<<<<<<<<<<<<<<

                 por Oscar Toledo G.
       (c) Copyright Oscar Toledo G. 2014-2016
                http://nanochess.org/
               E-mail: biyubi@gmail.com

Primera revisión: 14-ene-2014
Última revisión: 22-ene-2016


>>>>>>>>>>>>>>  Aviso legal

Este software se provee 'tal cual', sin garantía expresa o implicada. En
ningún caso el autor será responsable por algún daño o perdida derivados
del uso de este software.

Se prohibe modificar, decompilar, desensamblar o hacer ingeniería en reversa
de este software.

Todas las marcas pertenecen a sus respectivos propietarios.


ESTA ES LA TRADUCCIÓN AL ESPAÑOL DEL MANUAL DE INTYBASIC, EN CASO DE CUALQUIER
DIFERENCIA CON EL ORIGINAL INGLÉS, LA VERSIÓN EN INGLÉS TIENE LA PRIORIDAD.

Se hace referencia a muchos documentos Intellivision que sólo están disponibles
en inglés.


>>>>>>>>>>>>>>  Cambios en esta versión

v1.2.5 22-ene-2016  o Se agrega la sentencia PLAY VOLUME.
                    o Se agrega la sintaxis NO DRUMS a PLAY.
                    o La sentencia DO seguida por dos puntos ya no es tomada
                      como etiqueta.
                    o Se corrige un error en la detección de PAL.
                    o Actualizado constants.bas (correcciones y nuevas
                      constantes para modo Coloured Squares) y ejemplo
                      keypad.bas.
                    o Agregado contrib/ColouredSquares.bas un ejemplo de dibujo
                      de líneas en modo Coloured Squares por GroovyBee.
                      
v1.2.4 25-sep-2015  o Optimiza secuencias de instrucciones ANDI/XORI.
                    o Genera advertencia en caso de asignación a variable antes
                      asignada a CONST.
                    o Soluciona bug donde ELSEIF debía ser terminado con ELSE.
                    o Unas pocas advertencias devolvían un código de error
                      incorrecto.
                    o Advierte acerca de asignación a nombres de variables
                      internos.

v1.2.3 01-sep-2015  o Se agrega sentencia SIGNED para indicar arreglos y
                      variables de 8 bits con signo.
                    o La sentencia SPRITE ahora admite expresión para el indice
                      de MOB.
                    o SCREEN permite un sexto argumento para admitir una
                      pantalla origen ancha, útil para scroll horizontal o
                      para ilustrar una fracción de un gran mapa.
                    o Se soluciona un bug donde las advertencias eran tratadas
                      como errores para el código de retorno de la línea de
                      órdenes.
                    o Se soluciona un bug donde algunas advertencias no podían
                      ser desactivadas.
                    o Nuevo ejemplo: landscape.bas (sintaxis SCREEN adicional)

v1.2.2 24-ago-2015  o Nueva sentencia FLASH que permite el uso de la memoria
                      Flash en los cartuchos JLP.
                    o Nuevas variables FLASH.FIRST y FLASH.LAST de solo lectura.
                    o Añadido nuevo ejemplo: flash.bas
                    o Nueva contribución: 42k.bas (GroovyBee) muestra como crear
                      un programa IntyBASIC del tamaño máximo.
                    o Cuando se usa la opción --jlp la pila ahora se pone en la
                      RAM interna.
                    o Genera advertencia si se asigna valor mayor de 8 bits a
                      variable de 8 bits. Note que es advertencia en lugar de
                      error, ya que en ocasiones se utilizan valores negativos
                      en variables de 8 bits y no ocasiona ningún problema
                      usarlos para aritmética con otras variables de 8 bits.
                    o Genera error si el TO tiene un valor mayor de 8 bits
                      cuando se usa con variable de 8 bits.
                    o Genera advertencia para etiquetas definidas pero sin usar.
                    o Genera error para etiquetas redefinidas.
                    o Genera error para etiquetas indefinidas.

v1.2.1 16-ago-2015  o Se agrega arreglo #BACKTAB (acceso directo a pantalla)
                    o Generación de código optimizada para POKE.
                    o Optimiza suma de constante seguida por resta de constante.
                    o Se soluciona bug en que IF de bloque era generado mal.
                    o Se soluciona bug en que DEF FN se trababa en caso de error.

v1.2   08-ago-2015  o Nueva opción -w para desactivar advertencias de compilación.
                    o Se admiten cadenas en DEF FN y como argumentos para macro.
                    o Se agrega soporte para bloque IF/ELSEIF/ELSE/END IF.
                    o Nueva sentencia DO/LOOP.
                    o Nueva sentencia EXIT, use como EXIT FOR, EXIT WHILE o EXIT DO.
                    o Nueva función LEN()
                    o Nueva función POS()
                    o Se agrega semilla para generador pseudoaleatorio con basura RAM.
                    o Inicializa el procesador de sonido del ECS.
                    o Error o advertencia dentro de INCLUDE indica archivo.
                    o Se soluciona bug en que macros anidadas no funcionaban.
                    o Se solucionan varios bug en macros para multiplicación por const.
                    o Nueva contribución (tcg.bas) por catsfolly.
                    o Muchas mejoras en la utilidad IntyColor
                      o Opción -m para crear MOB (para tercer o cuarto color en mismo bloque)
                      o Opción -c para no incluir constants.c (opción -m)
                      o Opcion -r para generar BMP de reporte coloreado (error/GRAM/GROM)
                      o Opción -g para indicar como se desea usar los MOB (usar con -m)

v1.1   14-jul-2015  o Nueva función RANDOM()
                    o Nueva sentencia DEF FN para expresiones tipo macro.
                    o Soporte experimental para CONT3 y CONT4 sin decodif. teclas (ECS)
                    o INCLUDE ahora admite comillas y busca en camino de librería.
                    o Genera advertencia para variables asignadas pero no leídas y
                      también para variables leídas pero no asignadas.
                    o Algoritmo optimizado para multiplicación (ya no realiza suma
                      sucesiva que podía tomar un largo tiempo, 2 segundos en el
                      peor caso)
                    o Nuevo algoritmo rápido de división y resto para caso especial
                      de sólo variables como operandos.
                    o Soluciona bug donde multiplicación por 0 tomaba un largo tiempo.
                    o Ahora optimiza multiplicación por $0200, $0400 y $0800.
                    o Soluciona bug que ocasionaba que el código de ECS siempre se
                      incluyera.
                    o Soluciona bug en que algunas divisiones eran con signo.
                    o Se optimiza generación de código para multiplicación.
                    o Más optimización al generar código cuando el operando más
                      complejo está a la derecha del operador.
                    o Alguna optimización de mirilla para generación de código (al fin
                      salva código internamente para procesamiento posterior)
                        * Evita cargar registro con constante si aún está disponible.
                        * Evita leer memoria en registro si acaba de escribirla.
                        * Combina pares de instrucciones en formas más óptimas.
                        * La lectura de arreglos arreglo(const) es más rápida.
                        * Remoción de subexpresiones comunes para índice simple en arreglo.
                        * Optimiza resta múltiple.
                        * Optimiza comparaciones.
                        * Optimiza IF expr THEN GOTO.
                    * Nuevas contribuciones: keypad (GroovyBee), intro (Tarzilla) y
                      Hello (DZ-Jay)

v1.0.4 23-abr-2015  o Agregado soporte para el PSG secundario del ECS (sólo en
                      SOUND)
                    o Agregado RAND(rango) para tener número aleatorio en el rango
                      0..rango-1
                    o Ligera optimización en PRINT con espacios.
                    o Resto optimiza cada potencia de 2.
                    o Optimiza multiplicación por 32, 64 y 128.
                    o Optimiza división por 32, 64 y 128.
                    o Se agrega la rutina de intvnut para multiplicación rápida
                      (incluida sólo si utiliza variable * variable)
                    o Soluciona bug donde un RETURN dentro de IF era tomado como
                      un RETURN al final de PROCEDURE.
                    o Soluciona bug al contar variables de 8 bits y 16 bits.
                      Ahora debe estar correcto.

v1.0.3 17-feb-2015  o Agregado nuevo parametro PLAY NONE
                    o Agregadas nuevas sentencias WHILE/WEND
                    o Agregada función SGN.
                    o No toma algunas sentencias como etiqueta si están seguidas
                      por un símbolo de dos puntos.
                    o Devuelve código de error a la línea de comandos si la
                      compilación genera error o advertencia.

v1.0.2 25-ene-2015  o Permite cambiar el título del programa compilado.
                      (útil para emuladores y cartuchos múltiples)
                    o Permite usar la memoria extra del Cuttle Cart 3.
                      (lo mismo que JLP pero sin usar aceleración por
                      hardware para multiplicación y división)
                    o Permite usar la sintaxis CONT.* para verificar
                      los dos controles.
                    o Permite usar ON FRAME GOSUB.

v1.0.1 12-dic-2014  o Las sentencias DEFINE, SCREEN y PLAY permiten utilizar una
                      matriz como referencia, para faciliar la modificación
                      dinámica de los datos.
                    o La sentencia DEFINE admite sintaxis VARPTR.
                    o Se corrige el total de variables libres, indicaba una más
                      de lo disponible.
                    o De nuevo se optimización la generación de código para PRINT
                    o Generación de código optimizada para acceso a matriz y PEEK.
                    o Generación de código optimizada para árboles de sumas y
                      restas con constante.
                    o Utiliza macro ultra-optimizada para multiplicación hasta 127
                      (contribuida por DZ-Jay)
                    o Aceleración del código para decodificación de teclado
                      numérico.
                    o Versión Windows de IntySmap, ¡olvidé incluirla antes!
                    o Muchas gracias a Kiwi por contribuir Apple Catcher como un
                      juego de muestra.
                    o Muchas gracias a catsfolly por contribuir Clowns&Ballons
                      como un juego de muestra.

v1.0  21-nov-2014   o PRINT permite ilustrar números decimales utilizando una
                      librería provista por intvnut.
                    o Soporte para Intellivoice a través de la sentencia VOICE.
                    o Se agrega switch --jlp para utilizar aceleración via
                      hardware de multiplicación y división.
                    o El switch --jlp tambien activa el uso de memoria RAM de
                      16 bits en $8040-$9f7f (casi 8000 palabras para matrices y
                      variables)
                    o Se agrega función ABS.
                    o Se agrega soporte para READ A(x)
                    o Se agrega función USR para llamar fácilmente funciones en
                      ensamblador.
                    o Se agrega función VARPTR para pasar direcciones a funciones
                      en ensamblador.
                    o Se agrega DEFINE ALTERNATE
                    o Optimización de generación de código para expresiones
                      involucrando resta y casos a+(-b) y a-(-b).
                    o Optimización de generación de código para IF A AND 2
                    o Optimización de generación de código para PRINT con cadenas.
                    o Optimización de generación de código para = y <> con cero.
                    o Remueve RETURN extra al final si la combinación de sentencias
                      RETURN/END se usa.
                    o La sentencia MUSIC no activa inclusión del reproductor musical.
                      Sólo si PLAY es usado (útil para desactivar música)
                    o Advierte si PROCEDURE comienza sin terminar PROCEDURE previo
                    o Advierte si END es usado sin comenzar PROCEDURE
                    o Se agrega utilidad IntySmap para mapear código ensamblador a
                      código IntyBASIC
                    o Se agrega información extra a la salida ensamblador de IntyBASIC
                      para facilitar la depuración a nivel de código fuente.
                    o Se agrega script intbas.pl para estructurar directorios.

v0.9  10-oct-2014   o Se agrega sentencia ON GOTO/GOSUB.
                    o Se agrega sentencia STACK_CHECK.
                    o Se agrega sentencia INCLUDE.
                    o En sentencia DEFINE ahora se permiten expresiones en parametros
                      para el número de caracter y caracteres totales.
                    o Se agregan números de punto fijo 8.8 y suma y resta fija
                      (operadores +. y -.)
                    o Multiplicacion y división optimizadas para constante 256.
                    o Resto optimizado para constantes 32, 64, 128 y 256.
                    o Se agrega descripción extra para sentencias SOUND, MUSIC, MODE
                      y DEFINE.

v0.8  26-ago-2014   o Genera advertencia si no puede abrir los archivos de prólogo y
                      epílogo.
                    o Muestra el espacio total de variables usado si se excede el
                      espacio disponible.
                    o Soporte para números binarios, usando sintaxis &01010101
                    o Integra reproductor de música y sentencias PLAY/MUSIC
                    o Integra detección PAL/NTSC

v0.7  02-abr-2014   o Se agrega soporte para acceder códigos de caracter de las
                      letras del Intellivision.
                    o Nuevas sentencias MODE y SCREEN, todas las operaciones de video
                      del Intellivision son controladas con sentencias IntyBASIC, no
                      hay necesidad de usar POKE o PEEK.
                    o Las comparaciones ahora retornan $ffff para resultados
                      verdaderos, útil con NOT
                    o Se soluciona error donde CONT2 no funcionaba.
                    o Los siguientes dos son experimentales:
                      o Ahora CONT?.B0 B1 y B2 verifican los botones individuales.
                      o Se agrega soporte para teclados numéricos de los controladores.

v0.6  02-mar-2014   Se soluciona error en FOR STEP que permitía ir más allá de los
                    valores permisibles. Soporte para constantes con la sentencia
                    CONST. Se agrega ejemplo de corrección de offset de sprite en
                    SCROLL.BAS

v0.5  26-feb-2014   Se aceleran las rutinas de lenguaje ensamblador para los registros
                    de colisión. Se agregan sentencias SCROLL y BORDER. Soporte para
                    camino a librería en argumentos.

v0.4  11-feb-2014   Se soluciona un error en asignación a matriz con indice constante.

v0.3  06-feb-2014   Se agrega sentencia DIM y acceso indexado a matrices.
                    Se soluciona un error de caracteres extras no detectados en línea.
                    Se agrega detección de límite de memoria para variables.

v0.2  03-feb-2014   Más variantes de definición permitidas en sentencia BITMAP
                    Se agrega otro ejemplo title.bas
                    Soporte oficial para Mac OS X 10.6 (antes sólo 10.8 y 64-bits)
                    Soporte oficial para Linux

v0.1  28-ene-2014   Primera versión liberada.


>>>>>>>>>>>>>>  Descripción

Este es un compilador BASIC de números enteros para Intellivision, trabaja como un
compilador cruzado sobre una PC, Mac o Linux y genera código ensamblador que puede
ser procesado por as1600 (incluído con el emulador jzintv)

Plataformas disponibles:
  o PC con Windows XP o mejor.
  o Mac OS X 10.6 o mejor. (binario universal 32/64 bits)
  o Linux.

Las limitaciones actuales son:
  o La división y resto (módulo) tratan los números como sin signo.
  o Las constantes 32768-65535 no implican números sin signo, si son utilizadas en
    una comparación son con signo (-32768 - -1), todas las comparaciones son de
    16 bits con signo.
  o ASM no se puede usar dentro de DEF FN.
  o Usar PRINT para números siempre los muestra como sin signo de 0 a 65535.

Forma de uso:

  intybasic entrada.bas salida.asm [directorio_libreria]
  intybasic --jlp entrada.bas salida.asm [directorio_libreria]
  intybasic --cc3 entrada.bas salida.asm [directorio_libreria]
  intybasic --title "Mi lindo juego" entrada.bas salida.asm [directorio_libreria]

Los siguientes módulos son incluídos automáticamente como prólogo y epílogo del
código generado y contienen código de trabajo y ponen variables importantes:

    intybasic_prologue.asm
    intybasic_epilogue.asm

Por defecto estos son traídos del directorio actual a menos que escoja un camino
de librería.

Después puede ensamblar su programa usando as1600

  as1600 -o salida.bin -l salida.lst salida.asm

Y finalmente puede probarlo usando los emuladores jzintv o Nostalgia:

  jzintv salida.bin        Ejecución normal
  jzintv --jlp salida.bin  Correr con soporte JLP
  jzintv -v1 salida.bin    Correr con soporte Intellivoice
  
Otra alternativa es cargar el programa es un CuttleCart o Intellicart para probar en
un Intellivision de verdad.

También vea debajo para información sobre depuración a nivel de código fuente.

Los siguientes programas de ejemplo están incluídos:

  samples/constants.bas       Librería de constantes (usada por todos los ejemplos)
  samples/controller.bas      Prueba de los controladores Intellivision
  samples/flash.bas           Ejemplo de como utilizar memoria Flash de cartuchos JLP
  samples/frame.bas           Muestra de ON FRAME GOSUB
  samples/game1.bas           Un juego sencillo de dispara a la letra.
  samples/game2.bas           Un juego sencillo de laberinto con enemigos.
  samples/lander.bas          Juego del aterrizaje lunar
  samples/music.bas           Ejemplo sencillo de reproducción de música.
  samples/pak.bas             Juego de come puntos que incluye fantasmas ;)
  samples/screen.bas          Prueba de la sentencia MODE
  samples/scroll.bas          Ejemplo de como usar el scroll
  samples/sprites.bas         Ejemplo de sprites movibles
  samples/test.bas            Prueba del compilador, aún así pueden existir bugs.
  samples/title.bas           Caracter gráfico animado para pantalla de título
  samples/voice.bas           Ejemplo sencillo del uso de Intellivoice

  contrib/42k.bas             Ejemplo de como usar el mapa máximo de 42K palabras
  contrib/constants.bas       Librería de constantes (misma de samples)
  contrib/AppleCatcher.bas    Juego Apple Catcher por Kiwi
  contrib/clowns.bas          Juego Clowns & Ballons por catsfolly
  contrib/hello.bas           Hello World por DZ-Jay
  contrib/intro.bas           Introducción a IntyBASIC por Tarzilla
  contrib/keypad.bas          Keypad test por GroovyBee
  contrib/tcg.bas             Generador de comentarios tipo troll por catsfolly.

Se incluyen las siguientes utilidades:

  IntyColor            Convierte un bitmap a código fuente o gráficos de IntyBASIC.
  IntySmap             Convierte un archivo smap para referenciar código fuente de
                       IntyBASIC. Útil con el depurador de jzintv (opción -d y
                       --src-map). Vea la sección más adelante para mayor
                       información.


>>>>>>>>>>>>>>  Apoyando al desarrollador

Si encuentra que IntyBASIC es útil, por favor muestre su aprecio haciendo una
donación por Paypal (sugerido USD $9) a b+i-y+u-b+i-(at)-g+m-a+i-l-.-c-o+m

Si encuentra un error, por favor reportelo al mismo email y trataré de buscarlo.
Debido a mi falta de tiempo no puedo garantizar que será corregido.


>>>>>>>>>>>>>>  Especificación del lenguaje IntyBASIC
  
La ejecución comienza al inicio del programa BASIC.

Sintaxis por línea:
  [etiqueta:] sentencia[:sentencia] [' comentario]

  MAIN:    PRINT "HOLA"  ' Ilustra hola
  
Multiples sentencias se permiten separadas por un símbolo de dos puntos.
Las variables se crean simplemente con ser usadas.
Las etiquetas se crean simplemente con ser usadas.

Un nombre de variable empieza con una letra o # seguidos por letra, número o guión
bajo.

Las variables y matrices (vea DIM y abajo sección para total de variables permitidas)
pueden ser de 8 bits (un mínimo de 179 disponibles) o 16 bits (mínimo de 28
disponibles), por defecto las variables son de 8 bits, para usar 16 tamaño de 16 bits
utilice # como caracter inicial en el nombre.

    x
    y
    #score
    
Note que si utiliza el prefijo # debe usarlo en todo el programa, las variables sin
prefijo # son tratadas como variables diferentes de 8 bits.

Todas las variables contienen cero al comienzo. También IntyBASIC le advertirá si
excede el número de variables disponibles.

Las siguientes sentencias están disponibles:

  REM comentario
  ' comentario
  
     Todo desde REM hasta el final de la línea es un comentario

  SIGNED nombre[,nombre]
  
     Indica que los nombres son variables o arreglos de 8 bits con signo.

     Por defecto las variables de 8 bits no tienen signo.

     Note que esto agrega dos instrucciones para extender el signo a cada
     lectura de variable de 8-bits con signo, aunque IntyBASIC tratará
     de optimizar para evitar insertarlas.
     
     Por lo general puede desarrollar sus programas sin usar esta palabra
     clave, pero está disponible si se requiere.

  CONST [nombre]=[expresión constante]
  
     Asigna un nombre a una expresión constante. El compilador reemplazará
     este nombre en expresiones con el número mismo. Estos nombres tienen
     prioridad sobre las variables.

     Es una clase de directiva, no genera código y puede aparecer en cualquier
     punto del programa pero sólo será tomado como constante desde el punto
     de aparición y hacia adelante.

  GOTO etiqueta
  
     Salta a la etiqueta.
  
  GOSUB label       
  
     Va a la subrutina de la etiqueta (debe ser un PROCEDURE)

  etiqueta: PROCEDURE
  [código para subrutina]
  END
  
     Crea un PROCEDURE que puede ser llamado por GOSUB
     Es importante que PROCEDURE esté en la misma línea de la etiqueta

  RETURN            
  
     Retorna de una subrutina

  FOR A=inicio TO final [STEP incremento]
  NEXT     ' También se admite NEXT A
  
  FOR A=1 TO 5 ' Loop
  [La variable A contendrá 1,2,3,4,5]
  NEXT A
  
  FOR A=1 TO 5 STEP 2
  [La variable A contendrá 1, 3, 5]
  NEXT A
  
  FOR A=5 TO 1 STEP -2
  [La variable A contendrá 5, 3, 1]
  NEXT A
  
     Sentencia de bucle.
     
     Note que sólo puede utilizar variables normales para el bucle, no variables
     en matrices.
          
     Hay un pequeño detalle si se usan variables de 8 bits y la expresión TO es
     demasiado compleja y alcanza 0 o 255. El bucle puede ser infinito.

  WHILE expr:[sentencia]:WEND
  WHILE expr
  [sentencia]
  WEND
  
     Sentencia de bucle mientras la expresión se evalúe a un valor diferente de cero.

  DO WHILE expr:[sentencia]:LOOP
  DO WHILE expr
  [sentencia]
  LOOP

  DO UNTIL expr:[sentencia]:LOOP
  DO UNTIL expr
  [sentencia]
  LOOP
  
  DO:[sentencia]:LOOP WHILE expr
  DO
  [sentencia]
  LOOP WHILE expr
  
  DO:[sentencia]:LOOP UNTIL expr
  DO
  [sentencia]
  LOOP UNTIL expr
  
     Sentencia de bucle mientras (WHILE) la expresión se evalúa a un valor
     diferente de cero, o hasta que (UNTIL) la expresión se evalúa a un valor
     diferente de cero.
     
  EXIT FOR
    
     Sale de la sentencia FOR actual, salta justo después del NEXT.
     
  EXIT WHILE

     Sale de la sentencia WHILE actual, salta justo después del WEND.

  EXIT DO
     
     Sale de la sentencia DO actual, salta justo después del LOOP.

  IF expr GOTO [etiqueta]
  IF expr THEN [sentencia]
  IF expr THEN [sentencia] ELSE [sentencia]
  
  IF expr THEN
    [sentencia]
  END IF
  
  IF expr THEN
    [sentencia]
  ELSE
    [sentencia]
  END IF
  
  IF expr THEN
    [sentencia]
  ELSEIF expr THEN
    [sentencia]
  END IF

  IF expr THEN
    [sentencia]
  ELSEIF expr THEN
    [sentencia]
  ELSE
    [sentencia]
  END IF

     Sentencia de decisión

  ON expr GOTO [etiqueta],[etiqueta],[etiqueta]
  ON expr GOTO [etiqueta],,[etiqueta]
  ON expr GOTO ,,[etiqueta]
  ON expr GOSUB [etiqueta],[etiqueta],[etiqueta]
  ON expr GOSUB [etiqueta],,[etiqueta]
  ON expr GOSUB ,,[etiqueta]

     Sentencia de decisión
     
     La expresión es evaluada y si el resultado es cero, la primera etiqueta se toma
     y así sucesivamente.
     
     Si se usa GOSUB entonces debe asegurarse que cada etiqueta va a un PROCEDURE.
     
     Si la opción no tiene etiqueta o la expresión excede el número de etiquetas
     entonces el flujo de ejecución continúa en la siguiente sentencia después
     del ON.

  ON FRAME GOSUB label
  
     En cada cuadro de video, el código de apoyo de IntyBASIC llamará la etiqueta
     indicada.

     Note que esto no genera ningún código y sólo debe aparecer una vez en su
     programa.

     También puede ser llamado antes incluso de que sus rutinas de inicialización
     estén listas.
     
     Usted sólo puede asumir que cada variable es cero al inicio.

     También es su responsabilidad que el código no tome demasiado tiempo, de otra
     forma las interrupciones de video se acumularán y la pila de memoria
     se excederá.


  POKE dir,dato
  
     Escribe el dato indicado en la dirección de memoria del Intellivision.

  WAIT
  
     Espera la siguiente interrupción de video (1/60 seg. para NTSC o 1/50 para PAL)

  DIM var(tam)
  
     Crea una matriz de datos llamada 'var' con tamaño 'tam' elementos,
     el indice empieza en cero, así que DIM A(10) crea una matriz de 0 a 9.

     También se pueden crear matrices de 16-bits, utilizando DIM #GRANDE(10)

     La matriz puede ser accedida como sigue:

         A(1)=A(1)+5
         A(X)=A(Y)-2
         
     Esta es una clase de directiva, no genera código y puede aparecer en
     cualquier punto del programa.

  RESTORE label
  READ var
  READ var,var2
label:
  DATA expr_constante[,expr_constante]

    Útil para tener tablas/gráficos, los números pueden estar en el rango de 16 bits
    READ limitará automáticamente los datos al tamaño de la variable.
    
      READ A       ' Lee dato en A, limita a 8 bits
      READ #A      ' Lee dato en #A, sin limitaciones.
                   ' Note que A y #A son variables diferentes.
      READ A(B)    ' Lee dato en A(B)
      READ #A(B)   ' Lee dato en #A(B)
                   
    Todos los datos contenidos en DATA también pueden ser accedidos utilizando
    sintaxis de indice, de esta forma:
    
      FOR A=1 TO 5
      PRINT AT TABLA(A),"Z"
      NEXT A
      
      TABLA:
      DATA 21,42,63,84,105


  DEFINE num_car,total,etiqueta
  DEFINE num_car,total,VARPTR etiqueta(expr)
  DEFINE ALTERNATE num_car,total,etiqueta
  DEFINE ALTERNATE num_car,total,VARPTR etiqueta(expr)

    Carga gráficos en la GRAM en el número de caracter "num_car" (0-63) para
    un total de "total" caracteres. La etiqueta apunta a los gráficos (DATA o
    BITMAP)

    La etiqueta también puede ser una matriz de 16 bits para GRAM definido
    dinámicamente.

        DIM #grafico(4)
        
        DEFINE 0,1,#grafico
    
    Y la sintaxis VARPTR permite seleccionar un bitmap de múltiples definiciones.

    Los gráficos serán cargados en el siguiente cuadro (WAIT)

    Note que hay un límite de carga de 18 GRAM por cuadro (medido con el emulador
    en modo NTSC)
    
    Este límite se reduce a 16 caracteres GRAM por cuadro cuando se usa el
    reproductor musical (sentencia PLAY)
    
    Note que hay dos DEFINE: DEFINE y DEFINE ALTERNATE, esto le permite cambiar
    dos conjuntos separados de caracteres en un cuadro. Porque si usa DEFINE
    múltiples veces por cuadro sólo el más reciente se toma en cuenta.

  SOUND 0,[VALOR 12 bits],[VOL 0-15]       Canal A
  SOUND 1,[VALOR 12 bits],[VOL 0-15]       Canal B
  SOUND 2,[VALOR 12 bits],[VOL 0-15]       Canal C
  SOUND 3,[VALOR 16 bits],[TIPO 0-15]      Envolvente de volumen (frecuencia/forma)
  SOUND 4,[RUIDO 5 bits],[MIX]      Registro de ruido y mezcla ($38 por defecto)

  Sólo para el PSG secundario en el módulo extra ECS
  SOUND 5,[VALOR 12 bits],[VOL 0-15]       Canal A
  SOUND 6,[VALOR 12 bits],[VOL 0-15]       Canal B
  SOUND 7,[VALOR 12 bits],[VOL 0-15]       Canal C
  SOUND 8,[VALOR 16 bits],[TIPO 0-15]      Envolvente de volumen (frecuencia/forma)
  SOUND 9,[RUIDO 5 bits],[MIX]      Registro de ruido y mezcla ($38 por defecto)

    El valor deseado de frecuencia puede ser calculado como:

       valor = (3579545 / 32 / frec)
       
    Por favor note este cambio para PAL:

       valor = (4000000 / 32 / frec)
       
    El primer parametro sólo puede ser constante (0-4)
    
    Para los canales A, B y C, si usted utiliza el volumen 48 entonces el PSG utilizará
    la envolvente de volumen (vea SOUND 3)

    Utilice el volumen 0 para desactivar los canales de sonido en lugar de los bits del
    mezclador, tampoco use valor cero para el parametro de frecuencia en los canales A, B
    y C, es mejor usar 1 para obtener una respuesta rápida al cambiar de frecuencia.

    Más información sobre el PSG en:

      http://spatula-city.org/~im14u2c/intv/jzintv-1.0-beta3/doc/programming/psg.txt
      http://spatula-city.org/~im14u2c/intv/gi_micro_programmable_tv_games/page_7_100.png
      http://spatula-city.org/~im14u2c/intv/gi_micro_programmable_tv_games/page_7_101.png
      http://spatula-city.org/~im14u2c/intv/gi_micro_programmable_tv_games/page_7_102.png
      http://spatula-city.org/~im14u2c/intv/gi_micro_programmable_tv_games/page_7_103.png
      http://spatula-city.org/~im14u2c/intv/gi_micro_programmable_tv_games/page_7_104.png
      http://spatula-city.org/~im14u2c/intv/gi_micro_programmable_tv_games/page_7_105.png

    Si usted utiliza el reproductor musical entonces las capacidades de SOUND se ven
    afectadas, vea más adelante la sentencia PLAY.

  SPRITE indice,x,y,f
  
    El primer parametro indica el número de MOB (0-7). Note que si utiliza una constante el
    código generado será más rápido. El sprite (MOB) será actualizado en el siguiente cuadro.

    X contiene la coordenada X (0-168)
    bit 8 = Interacción (se sugiere 1 siempre)
    bit 9 = Visibilidad (se sugiere 1 siempre)
    bit 10 = Tamaño X doble
    
    Y contiene la coordenada Y (0-95)
    bit 7 = Dibuja sprite de 16 líneas. (debe alinearse en una frontera par de GRAM 0/2/4/8 etc)
    bits 9-8 = Escala 00= 0.5x, 01= 1x, 10= 2x, 11= 4x
    bit 10 = Espejo X
    bit 11 = Espejo Y
    
    F contains color y número de caracter o dibujo
    bits 2-0 = Bits bajos de color
    bits 11-3 = Número de caracter (0-255 para GROM, 256-319 para GRAM)
    bit 12 = Bit superior de color
    bit 13 = Cambio de stack de color
    
    Los valores X,Y,F son escritos tal cual al STIC, por favor verifique especificaciones
    en:

      http://spatula-city.org/~im14u2c/intv/jzintv-1.0-beta3/doc/programming/stic.txt
    
  CLS
  
    Limpia la pantalla con 0.
    También reinicia la posición del cursor a la posición superior izquierda de la pantalla.

  PRINT [AT [expr]][COLOR [expr]][,]"cadena"[,"cadena"]

    Ilustra la cadena en la posición actual del cursor (o seleccionado mediante valor
    0-239 en AT). La cadena es convertida automáticamente de caracteres ASCII a
    Intellivision and XOReado con el color actual ($0000-$0007, $1000-$1007 o $2000 para
    stack de color)

    Para el modo Foreground/Background, use $0000-$0007, y $0200 es el bit 0 del color
    de fondo, $0400 es el bit 1 del color de fondo, $1000 es el bit 2 del color de
    fondo y $2000 es el bit 3 del color de fondo. (vea la sentencia MODE más adelante)

    Note que la posición del cursor no está limitada, usted puede escribir fuera de la
    pantalla y "romper" su programa.

    Si usted quiere usar el GROM >= 96 o GRAM (256-319) usted puede usar la barra
    invertida como escape (por ejemplo \96\256\319)

    Si usted quiere usar comillas dobles dentro de una cadena puede escapearlas de
    esta forma \"

    Ejemplos de posicionamiento:
        PRINT AT 0,"A" ' esquina superior izquierda
        PRINT AT 19,"B" ' esquina superior derecha
        PRINT AT 220,"C" ' esquina inferior izquierda
        PRINT AT 239,"D" ' esquina inferior derecha
        
    Ejemplo:
    
        PRINT AT 84 COLOR (RAND AND 7),"HOLA MUNDO"
        PRINT "HOLA MUNDO"  ' Comienza en posición previa de cursor
  
  PRINT <>expr          ' Número sencillo
  PRINT <const>expr     ' Alineado a la derecha con ceros en tamaño 'const'
  PRINT <.const>expr    ' Alineado a la derecha con espacios en tamaño 'const'

    Imprime un número decimal en la posición actual con el color actual.

    Se pueden agregar opciones AT y COLOR.
    
    Ejemplo:

        PRINT AT 5 COLOR 6,"Puntos:",<6>#score,"00"
  
  PRINT [AT [expr],]expr[,expr]
  
    Escribe el valor de 12 bits directamente en pantalla, útil para cosas variables
    y caracteres GRAM.

    Para el formato por favor consulte la especificación del STIC citada arriba o la
    descripción F de SPRITE.

    También incrementa la posición del cursor.
    
    Ejemplo. Ilustra un número en amarillo:
    
        PRINT (DIGIT+16)*8+6
        
  SCROLL [offset_x],[offset_y],[mueve_pantalla]
  
    Permite realizar scroll de la pantalla pixel a pixel. El offset X y Y pueden ser
    cualquier número entre 0 y 7.

    Una vez que se pasa la frontera de los 8 pixeles, puede emitir una orden
    mueve_pantalla como esta:

        1 = Scroll a la izquierda
        2 = Scroll a la derecha
        3 = Scroll hacia arriba
        4 = Scroll hacia abajo

    La orden será procesada en el siguiente cuadro o interrupción.

    Note que una vez que utilice la sentencia SCROLL, automáticamente tendra
    ligeramente menos variables de 16 bits, ya que hay necesidad para un buffer e
    IntyBASIC incluirá código extra para el scrolling.
    
    También note que el chip de video del Intellivision (STIC) requiere que usted
    corrija la posición de los sprites cuando hace scrolling. Vea el ejemplo SCROLL.BAS

  BORDER [color],[mascara]
  
    Permite escoger el color de borde y también enmascarar los bordes para scrolling.

    El color puede ser cualquier número entre 0 y 15.

    La mascara puede ser 0, 1 (enmascara columna izquierda), 2 (enmascara línea superior)
    o 3 (enmascara ambos)

    El borde y la mascara serán actualizados en el siguiente cuadro de video.

  MODE 0,color1,color2,color3,color4
  MODE 1
  
    Permite seleccionar el modo de video (modo Color Stack o Foreground/background)
    esto sucede en el siguiente cuadro de video (WAIT)

    Note que no puede usar PRINT AT hasta que WAIT haya ocurrido, debido a que la
    variable de color es usada para salvar datos, después de esto COLOR será reiniciado
    a 7.

    En el modo Color Stack usted puede escoger cuatro colores de fondo disponibles en
    el rango 0-15.
    
    En el modo Foreground/Background usted tiene acceso a 16 colores de fondo pero
    sólo puede usar los caracteres 0-63 (conjunto de caracteres básico y letras
    mayúsculas) y los caracteres definidos 256-319.
    
  SCREEN etiqueta[,offset_origen,offset_destino,columnas,lineas]
  SCREEN etiqueta[,offset_origen,offset_destino,columnas,lineas,ancho_origen]

    Permite copiar datos de pantalla al video en una forma rápida. Usando solamente
    "SCREEN etiqueta" copia una pantalla completa de 20x12 caracteres al video.
    
    'etiqueta' apunta a una etiqueta dentro de su programa conteniendo los datos para
    la pantalla, similar a esto:

      mi_pantalla:
        DATA $0007,$000F,$0007,$000F   ' Y así...
        
    offset_origen es el offset (0-199 o más) dentro de la pantalla origen.
    offset_destino es el offset (0-199) dentro de la pantalla de video destino.
    columnas es el tamaño en columnas de la copia.
    lineas es el tamaño en líneas de la copia.
    ancho_origen es el ancho de la pantalla origen, útil para copiar una ventana
                 de una gran pantalla gráfica, como un mapa o cuando se hace
                 scroll horizontal. (por defecto, 20 igual que el tamaño de
                 horizontal de la pantalla del Intellivision)

    Esto puede servir para desplazar elementos grandes en el video, o para mostrar
    hermosas pantallas gráficas.

    La etiqueta también puede ser un arreglo de 16 bits para elementos dibujados
    dinámicamente:

        DIM #cards(4)
        
        SCREEN #cards,0,0,4,1


  BITMAP "00000000"
  BITMAP "00001111"
  
  BITMAP "________"
  BITMAP "____XXXX"
  
    Permite dibujar usando binario, usted debe poner las sentencias BITMAP en pares
    ya que se declaran en ensamblador usando DECLE

    Más útil al asignar una etiqueta y usando junto con DEFINE.

    Los caracteres tomados como cero binario incluyen: "0" "_" " " "."
    Todos los demás caracteres serán tomados como uno binario.
    
  PLAY SIMPLE
  PLAY SIMPLE NO DRUMS
  PLAY FULL
  PLAY FULL NO DRUMS
  
    Activa el reproductor de música y selecciona el tipo de música reproducida,
    SIMPLE utilizará solo dos canales, permitiendo al usuario usar SOUND 2 para
    efectos de sonido.

    FULL utilizará los tres canales. SOUND no puede ser usado en este caso.
    
    El reproductor de música tocará tambores usando el canal de ruido y el
    registro de mezcla, se puede desactivar esto usando la sintaxis NO DRUMS,
    por ejemplo si se desea crear sonidos de explosiones en el canal de ruido,
    permitiendo usar SOUND 4.

    Note que cada cuadro de video se actualizan los registros de sonido.

    Note que si utiliza la sintaxis NO DRUMS, es necesario que inserte esta
    sentencia justo después de la sentencia PLAY para poner el valor correcto
    en el registro de mezcla: (el reproductor ya no lo modifica)

      SOUND 4,,$38

  PLAY NONE
  
    Desactiva el reproductor de música. A continuación el usuario debe apagar
    los canales de sonido, utilizando este código:

      SOUND 0,1,0
      SOUND 1,1,0
      SOUND 2,1,0
      SOUND 4,1,$38

  PLAY VOLUME expr

     Pone volumen para reproducción de música (0 es silencio, 1 es volumen
     mínimo y 15 es volumen máximo)
     
     Si se utiliza esta sentencia, no debe olvidar poner PLAY VOLUME 15 al
     inicio de su programa, debido a que el volumen será 0 al inicio (silencio)

     Note que esto incluirá código extra dentro de su programa (alrededor de
     300 palabras) y usará ligeramente más ciclos en cada cuadro de video.

  PLAY etiqueta
  
    Reproduce la música apuntada por 'etiqueta'.

    La etiqueta también puede ser una matriz de 16 bits para cargar música generada
    dinámicamente.

    IntyBASIC incluirá automáticamente el código extra para un reproductor musical.

    La música debe estar en este formato: (cada sentencia MUSIC puede tener hasta
    4 argumentos)

        label:  DATA 8       ' Ticks por nota (hay 50 ticks en un segundo)
                MUSIC F4,A4#,C5
                MUSIC S,S,S
                MUSIC -,-,-

                MUSIC REPEAT
                MUSIC STOP

                MUSIC C4,F4,- ' Note como C4 se extiende por 4 tempos y F4 sólo 2
                MUSIC S,S,-
                MUSIC S,-,-
                MUSIC S,-,-
                
    Identificadores para notas: Nota C (DO), D (RE), E (MI), F (FA), G (SOL), A (LA), 
                           B (SI) seguida por octava (2-6), y también disponible C7.
                           Opcionalmente agregue el símbolo # para sostenido.

                           Opcionalmente agregue W para instrumento 0 (piano),
                           X para 1 (clarinete), Y para 2 (flauta), Z para 3 (bajo)

                           Seleccionar instrumento se pasa por cada canal a la
                           siguiente sentencia MUSIC si estos no especifican
                           instrumento.
                           
                           Note que la forma de onda de los instrumentos puede ser
                           alterada modificando el archivo intybasic_epilogue.asm
                           por cada programa suyo.

                           El usuario también puede poner S para sostener la nota
                           previa.
                           
                           El usuario también puede usar - para silencio.

                           El cuarto argumento para MUSIC también permite tambores:
                             Los valores válidos son:
                                -  ninguno
                                M1 fuerte
                                M2 tap
                                M3 repique

    IntyBASIC detectará automáticamente Intellivision PAL/NTSC y ajustará el tiempo de
    la música de forma acorde.

  PLAY OFF
  
    Detiene la música
    
  VOICE INIT
  
    Inicia el soporte Intellivision, debe ser lo primero antes de usar Intellivoice.
    
    Detectará automáticamente si el Intellivoice está conectado para poder usarlo.

  VOICE PLAY etiqueta
  
    Comienza a hablar, si la cola está llena entonces algunas frases pueden perderse.

    La etiqueta puede ser una matriz de 16 bits, esto permite construir frases
    dinámicamente.

  VOICE PLAY WAIT etiqueta
  
    Comienza a hablar, pero espera a que la frase se halla hablado por completo.
  
    La etiqueta puede ser una matriz de 16 bits, esto permite construir frases
    dinámicamente.

  VOICE WAIT
  
    Espera a que la cola de voz quede vacía.

  VOICE NUMBER expr
  
    Convierte una expresión a un número hablado (en inglés)

  VOICE phrases[,phrases]
  
    Datos para frases, utilice 0 para finalizar una frase, por ejemplo:

        VOICE INIT
        VOICE PLAY WAIT numbers
        VOICE PLAY WAIT lets_play
        VOICE NUMBER 147
    loop:
        GOTO loop
        
    numbers:  VOICE ONE,THREE,SIX,HUNDRED,0
    
    lets_play: VOICE LL, EH, EH, PA1, TT2, SS, PA2, PP, LL, EH, EY, PA2, 0
    
    Las frases permitidas son:

        PA5, PA4, PA3, PA2, PA1
        MATTEL, ZERO, ONE, TWO, THREE, FOUR, FIVE, SIX, SEVEN, EIGHT, NINE
        TEN, ELEVEN, TWELVE, THIRTEEN, FOURTEEN, FIFTEEN, SIXTEEN, SEVENTEEN
        EIGHTEEN, NINETEEN, TWENTY, THIRTY, FOURTY, FIFTY, SIXTY, SEVENTY
        EIGHTY, NINETY, HUNDRED, THOUSAND, TEEN, TY, PRESS, ENTER, OR, AND
        AA, AE1, AO, AR, AW, AX, AY, BB1, BB2, CH, DD1, DD2, DH1, DH2, EH,
        EL, ER1, ER2, EY, FF, GG1, GG2, GG3, HH1, HH2, IH, IY, JH, KK1,
        KK2, KK3, LL, MM, NG1, NN1, NN2, OR2, OW, OY, PP, RR1, RR2, SH, SS
        TH, TT1, TT2, UH, UW1, UW2, VV, WH, WW, XR2, YR, YY1, YY2, ZH, ZZ


  FLASH INIT
  
    Esta debe ser la primera sentencia utilizada si desea utilizar las
    funciones FLASH.
    
    Sólo tiene que ponerse una vez al principio del programa.

  FLASH ERASE linea

    Borra el número de línea dado por la expresión. El número de línea puede
    ir desde FLASH.FIRST hasta FLASH.LAST

    Esta operación borra un sector completo, un sector se compone de un
    múltiplo de 8 líneas. Así que borrar cualquier línea dentro de un múltiplo
    de 8 borrará las 8 líneas contenidas.
    
    Necesita invocar IntyBASIC con la opción --jlp

  FLASH READ linea,VARPTR #arreglo(0)
  
    Lee el número de línea dado por la expresión y pone el contenido dentro
    del arreglo (debe ser de 16 bits y 96 elementos). El número de línea
    puede ir desde FLASH.FIRST hasta FLASH.LAST

    Necesita invocar IntyBASIC con la opción --jlp

  FLASH WRITE linea,VARPTR #arreglo(0)
  
    Escribe el número de línea dado por la expresión y pone el contenido
    del arreglo (debe ser de 16 bits y 96 elementos). El número de línea
    puede ir desde FLASH.FIRST hasta FLASH.LAST

    Observe que solo puede escribir una línea >borrada<, esto significa que
    una vez escrita una línea no puede ser reescrita de nuevo hasta que se
    borre su sector.

    Necesita invocar IntyBASIC con la opción --jlp

    No olvide usar la opción --jlp de jzintv y --jlp-savegame=archivo

    ADVERTENCIA: SU PROGRAMA INTYBASIC PONDRA LA PANTALLA EN NEGRO Y SE
    DETENDRA POR UNOS POCOS MILISEGUNDOS MIENTRAS SE COMPLETAN LAS OPERACIONES
    JLP FLASH, ESTO INCLUYE LA MUSICA DE FONDO.


  DEF FN func = RAND % 10
  DEF FN screen_off(linea, columna) = (linea * 20 + columna)
  DEF FN resetsprite(number) = SPRITE number,0

    Permite definir funciones con cualquier número de argumentos.

    Observe que son tomadas como macros, los argumentos son reemplazados tal cual
    y el texto de la función es insertado tal cual después de reemplazar argumentos.
    (por eso se incluyeron los parentesis en la expresión de screen_off)

    Por ejemplo, las dos funciones superiores pueden ser llamadas como:

          A = func
          PRINT AT screen_off(4,8),"HELLO!"
          resetsprite(0)
          
    Note que aunque es posible reutilizar nombres de funciones internas, al ser
    llamadas las funciones internas tienen prioridad sobre DEF FN. (significa que
    DEF FN será ignorado)

  STACK_CHECK
  
    Esta sentencia en cualquier parte dentro de su programa activará un código que
    revisará sobrepasamiento de la pila dentro de la rutina de interrupción de
    video.
    
    Si la pila excede el límite permitido, detendrá su programa y mostrará un
    prominente mensaje de advertencia en pantalla diciendo "Stack overflow"

    Esto sucede por lo común cuando se hace GOSUB a PROCEDURE y saliendo con GOTO
    en lugar de RETURN.

  INCLUDE "archivo.bas"
  
    Permite incluir otro archivo dentro del programa IntyBASIC actual, note que no
    puede usar INCLUDE recursivamente.

    También que INCLUDE permite incluir cualquier cosa dentro de su prograna,
    incluso puede tener medio procedimiento en el archivo principal y el resto en
    su archivo incluido.
    
    Muy útil para separar archivos de gráficos y pantallas.

    Intentará primero incluir el archivo del directorio actual y luego intentará
    agregar el camino de librería provisto en la línea de órdenes.

  ASM código
  
    Permite insertar directamente código ensamblador. Se copia directamente a la
    salida.

    Esto también es muy útil para incluir módulos de código ensamblador, como esto:

        ASM INCLUDE "suarchivo.asm"
        

>>>>>>>>>>>>>>  Sintaxis de expresiones

La sintaxis de las expresiones es como en una calculadora.

Las reglas usuales de precedencia se aplican a los operadores de expresión (la suma y
la resta tienen menos prioridad que la multiplicación y la división)

  A=5               Número decimal
  A=$1000           Número hexadecimal
  A=&10101          Número binario
  #A=1.5            Número fijo (transladado a $8001, note que el byte alto es la fracción)
                    Note el uso de variable de 16 bits

  A="C"             Código de caracter Intellivision para letra
  A=B               Asignación simple
  A=A+B             Suma simple
  A=A-B             Resta simple
  #A=#A+.#B         Suma fija (note el uso de variables de 16-bits)
  #A=#A-.#B         Resta fija (note el uso de variables de 16-bits)
  A=A*B             Multiplicación simple
                    La multiplicación por 2/4/8/16/32/64/128/256/512/1024/2048/4096 es
                    optimizada internamente.
                    La multiplicación por constantes hasta 127 es optimizada con una macro.
                    La multiplicación utiliza un algoritmo de corrimiento que es relativamente eficiente en la mayoría de los casos. (42 ciclos mínimo o hasta 702 en el peor caso)
                    La multiplicación de variable por variable utiliza la rutina acelerada
                    de multiplicación de intvnut.
                    Cuando se utiliza el switch --jlp la multiplicación se acelera por
                    hardware.
  A=A/B				División simple sin signo (realizada por resta repetida, puede ser lenta)
                    La división por 2/4/8/16/32/64/128/256 es optimizada internamente.
                    La división de variable por variable utiliza mi rutina acelerada de
                    división (214 hasta 517 ciclos)
                    Cuando se utiliza el switch --jlp la división se acelera por hardware.
  A=A%B				Resto simple sin signo.
                    Note que la operación de resto se realiza por resta repetida (puede
                    ser lenta)
                    Resto o módulo por potencias de 2 usa AND internamente.
                    El resto de variable por variable utiliza mi rutina acelerada de
                    división (214 hasta 517 ciclos)
  A=(A+B)-C
  A=A AND B
  A=A OR B			Esta operación no es nativa, así que no es eficiente
  A=A XOR B
  A=NOT A
  A=-A
  A=A=B             Si A y B son iguales el resultado es $ffff (-1) de lo contrario es cero.
  A=A<>B
  A=A<B
  A=A>B
  A=A<=B
  A=A>=B
  A=PEEK(expr)		Lee la dirección de memoria indicada.
                    PEEK siempre lee datos de 16 bits que pueden ser procesados en la
                    expresión.
  A=ABS(expr)       Obtiene valor absoluto para expresión (no negativo)
  A=SGN(expr)       Obtiene el signo de la expresión (-1, 0 or 1)
  A=matriz(expr)    Accede matriz. La matriz puede ser definida con DIM, o ser una
                    etiqueta de DATA.
  matriz(expr)=A    Escribe matriz. La matriz puede ser definida con DIM, y DATA no es
                    escribible.

  A=USR NOMBRE        Llama función ensamblador NOMBRE con argumentos.
  A=USR NOMBRE(expr)  Llama función ensamblador NOMBRE con un argumento en R0.
  A=USR NOMBRE(expr,expr)  Llama función ensamblador NOMBRE con dos argumentos en R0 y R1.
                    (hasta 4 admitidos)
                    Funciones ensamblador pueden poner resultados en R0.
  #A=VARPTR B       Obtiene apuntador a variable. Útil al enlazar rutinas en ensamblador.
  #A=VARPTR C(0)    Obtiene apuntador a matriz. Puede ser definida con DIM o ser etiqueta
                    de DATA.

  CONT				Contiene el valor complementado de la dirección $01ff (controlador izq.)
  CONT.UP			No cero si algún controlador se desplaza arriba
  CONT.DOWN         No cero si algún controlador se desplaza abajo
  CONT.LEFT         No cero si algún controlador se desplaza a la izquierda
  CONT.RIGHT		No cero si algún controlador se desplaza a la derecha
  CONT.BUTTON	 	No cero si algún controlador tiene un botón oprimido.
  CONT.B0           No cero si algún controlador tiene un botón superior oprimido (izq/der)
  CONT.B1           No cero si algún controlador tiene el botón inferior izquierdo oprimido.
  CONT.B2           No cero si algún controlador tiene el botón inferior derecho oprimido.
  CONT.KEY          Tecla oprimida actualmente (0-9 para números, 10-Clear, 11-Enter, 12-No oprimida)
                    En cualquiera de los controladores.
                    Debido a que los movimientos pueden ser tomados como teclas, se sugiere
                    esperar a que CONT.KEY contenga 12 antes de esperar por una tecla.

  CONT1				Contiene el valor complementado de la dirección $01ff (controlador izq.)
  CONT1.UP			No cero si el controlador se desplaza arriba
  CONT1.DOWN		No cero si el controlador se desplaza abajo
  CONT1.LEFT		No cero si el controlador se desplaza a la izquierda
  CONT1.RIGHT		No cero si el controlador se desplaza a la derecha
  CONT1.BUTTON		No cero si algún botón del controlador está oprimido
  CONT1.B0          No cero si alguno de los dos botones superiores del controlador de oprimen (izq/der)
  CONT1.B1          No cero si el botón inferior izquierdo del controlador está oprimido.
  CONT1.B2          No cero si el botón inferior derecho del controlador está oprimido.
  CONT1.KEY         Tecla oprimida actualmente (0-9 para números, 10-Clear, 11-Enter, 12-No oprimida)
                    Debido a que los movimientos pueden ser tomados como teclas, se sugiere
                    esperar a que CONT1.KEY contenga 12 antes de esperar por una tecla.

  CONT2				Contiene el valor complementado de la dirección $01fe (controlador der.)
  CONT2.UP			No cero si el controlador se desplaza arriba
  CONT2.DOWN		No cero si el controlador se desplaza abajo
  CONT2.LEFT		No cero si el controlador se desplaza a la izquierda
  CONT2.RIGHT		No cero si el controlador se desplaza a la derecha
  CONT2.BUTTON		No cero si algún botón del controlador está oprimido
  CONT2.B0          No cero si alguno de los dos botones superiores del controlador de oprimen (izq/der)
  CONT2.B1          No cero si el botón inferior izquierdo del controlador está oprimido.
  CONT2.B2          No cero si el botón inferior derecho del controlador está oprimido.
  CONT2.KEY         Tecla oprimida actualmente (0-9 para números, 10-Clear, 11-Enter, 12-No oprimida)
                    Debido a que los movimientos pueden ser tomados como teclas, se sugiere
                    esperar a que CONT1.KEY contenga 12 antes de esperar por una tecla.

                    Note que utilizar la sintaxis .KEY hará que se incluya código extra de IntyBASIC.
                    También debe usar WAIT antes de la lectura de .KEY debido a que es cuando
                    IntyBASIC procesa el antirebote y decodifica teclas. Recuerda que esto
                    utiliza tiempo de procesador extra.
                    
                    Información útil para evitar que las pulsaciones de teclas se tomen como
                    movimientos:
                    
                        c = cont2.button
                        IF (c = $20)+(c = $40)+(c = $80) THEN GOTO evita_disco  ' Ignora teclas
                        ...comprobación de disco...
                    evita_disco:

  COL0
  COL1
  COL2
  COL3
  COL4
  COL5
  COL6
  COL7
    Obtiene la colisión entre sprites por cuadro, utilice de preferencia después de WAIT
    No olvide poner el bit de interacción en sprites (bit 8 de coordenada X)
    El bit 0-7 significa colisión contra sprite del número indicado.
    El bit 8 indica colisión contra pixel del fondo (pixel puesto)
    El bit 9 indica colisión contra los bordes.

  RAND
    Obtiene un número seudoaleatorio entre 0 y 255. Se actualiza en cada cuadro de video.

  RAND(rango)
    Obtiene un número seudoaleatorio entre 0 y rango - 1. Se actualiza en cada cuadro de
    video. Note que es más lento de generar, los más rápidos se basan en poderes de 2.
    También el rango se limita a un máximo de 256.

  RANDOM(rango)
    Obtiene un número seudoaleatorio entre 0 y rango - 1. Forza actualización del número
    aleatorio (no hay necesidad de WAIT). Note que es más lento de generar, los más
    rápidos se basan en poderes de 2. También el rango se limita a un máximo de 256.

  LEN(cadena)
    Devuelve la longitud de la cadena. Muy útil en combinación con DEF FN.
    Por ejemplo para crear texto centrado en la pantalla.

  POS(expr)
    Devuelve la posición actual en la pantalla (útil para PRINT AT)
    La expresión es analizada pero no genera ningún código.

  FRAME
    Obtiene el número de cuadro actual (0-65535, y vuelve a cero)
    
  NTSC
    Contiene 1 si el Intellivision es NTSC.

  #MOBSHADOW(x)
    Accede elementos del buffer MOB (el lugar donde se guardan los datos de SPRITE)
    Los elementos 0-23 replican exactamente las locaciones 0-23 del STIC
    
  #BACKTAB(x)
    Accede elementos del buffer de pantalla (ubicado en $0200-$02EF)

  FLASH.FIRST
    Primer línea que puede ser leer/escrita de la memoria Flash JLP.

  FLASH.LAST
    Última línea que puede ser leer/escrita de la memoria Flash JLP.


Los números fijos son útiles para mover elementos del juego en pasos fraccionales, el
truco es preservar la coordenada actual en una variable de 16 bits, y cuando se use para
la ilustración final debe copiarse este valor a una variable de 8 bits (cortando la
parte fija) o usar AND 255 o %256 ya que están optimizadas para este propósito.

Más acerca de los números fijos utilizados en IntyBASIC:

  http://atariage.com/forums/topic/229168-now-available-intybasic-compiler-v08/page-2#entry3080617


>>>>>>>>>>>>>>  Algunas notas extras

La ejecución es secuencial a menos que se interrumpa por GOTO o GOSUB. En cualquiera de
sus programas debe poner GOTO al final del bloque principal, de otro modo la ejecución
corre libremente, por ejemplo:

Ejemplo 1:

    A = 5
  stop:	GOTO stop	' Evita que el BASIC se salga del ROM


Ejemplo 2:

    A = 5
  stop:   GOTO stop	' Evita que la ejecución pase al PROCEDURE

  test:	PROCEDURE
		END

Si se inserta DATA, MUSIC o datos de VOICE en el medio de la secuencia de ejecución,
el procesador del Intellivision hará cosas extrañas. Así que ponga sus datos al
final del programa o donde la ejecución no los alcance.

Ejemplo 3:

    A = 6
    DATA 5,6,7      ' Mal, ¡esto se ejecuta! mover después del GOTO
  stop:    GOTO stop
        

El video empieza en modo de color-stack, cada caracter de la pantalla de 20x12 puede
tener el bit 13 puesto a 1 para que avance el apuntador actual del color-stack y
cambie el color del fondo.

Para poder cambiar los 4 valores predefinidos del color-stack, usted debe usar esto:

    MODE 0,1,2,3,4  ' Selecciona el color azul como inicial y otros 3 colores más.
    
Los valores de color están en el rango 0-15.

Para seleccionar el modo foreground/background, debe usar esto:

    MODE 1

IntyBASIC por defecto comienza el programa en el área de $5000, ustred tiene espacio
disponible hasta $6fff, este es un binario de 16K bytes (8K-words)

Puede medir su programa leyendo el archivo generado LST creado por el ensamblador o
el archivo CFG.

De cualquier forma, puede insertar sentencias ASM para crear programas mayores, como
esto:

    ASM ORG $D000
    
    ASM ORG $F000
    
De esta forma usted puede usar las áreas $D000-$DFFF y $F000-$FFFF. Es más fácil
manejar y calcular el espacio disponible si sólo pone datos en esas áreas.

Otra forma es mirar el archivo generado .lst, así puede ver que locaciones de memoria
son usadas por el código generado por IntyBASIC.

Usando cartuchos Flash modernos y PCBs homebrew para cartuchos le permite usar las
siguientes direcciones adicionales sin programación extra:

     $2000-$2FFF
     $5000-$6FFF
     $A000-$BFFF
     $C100-$FFFF
     
     
>>>>>>>>>>>>>>  Número total de variables permitidas

El total de variables de 8 bits permitidas es:

        228
        
        Reste 3 si usa SCROLL
        Reste 3 si usa VOICE
        Reste 6 si usa el teclado
        Reste 26 si usa PLAY

El número de variables de 16 bits permitadas son:

        47 (7962 si usa el switch --jlp o --cc3)

        Reste 20 si usa SCROLL or 30 si usa VOICE

Note que cada locación de una matriz asignada con DIM cuenta como una variable.


>>>>>>>>>>>>>>  Generando archivos ROM para el emulador Nostalgia

Por defecto el ensamblador as1600 genera un par de archivos .bin/.cfg, ambos pueden
ser copiados en el directorio ROM del emulador Nostalgia para probar sus programas.

Otra alternativa es convetir ambos archivos a un archivo .rom único, usando la
utilidad bin2rom incluída con jzintv:

    bin2rom juego.bin
    
Generará un archivo juego.rom que contiene una mezcla de los archivos .bin y .cfg
y es más fácil de probar con Nostalgia. 

Otra alternativa es usar el ensamblador as1600 con esta invocación para generar un
archivo .rom en la misma ejecución:

  as1600 -o salida -l salida.lst salida.asm

         
>>>>>>>>>>>>>>  Depuración de código fuente

He incluído suficiente información en el archivo generado ASM y con ayuda
invaluable de intvnut ahora hay soporte para depuración básica con el código
fuente de IntyBASIC mostrado mientras tanto.

Necesita compilar su programa de esta forma:

  intybasic entrada.bas salida.asm
  as1600 -j salida.smap -s salida.sym -o salida.bin -l salida.lst salida.asm 
  intysmap salida.smap
  jzintv -d salida.bin --src-map=salida.smap --sym-file=salida.sym  

Después de esto puede usar normalmente las órdenes de depuración de jzintv.

Note para Windows que su ventana principal debe ser de 160 columnas o más ancha,
utilice la orden de jzintv >160 para expandir la ventana si es necesario.


>>>>>>>>>>>>>>  Permisos en Mac OS X y Linux

Los ejecutables comprimidos para Mac OS X y Linux probablemente no tendrán
los permisos correctos cuando se descompriman.

Así que se sugiere ejecutar estas órdenes en su directorio IntyBASIC:

  chmod 755 intybasic
  chmod 755 intybasic_linux

Si su directorio IntyBASIC no está en el path actual puede ejecutarlo usando
esto mientras se halla en el directorio de IntyBASIC:

  ./intybasic juego.bas juego.asm

También puede estructurar sus directorios IntyBASIC usando el script intbas.pl
provisto por James Pujals (DZ-Jay), las estructuras requeridas son las
siguientes:

=============================================================================
CAMINO DE ARCHIVOS:                     DESCRIPCIÓN:
=============================================================================
+-- intybasic                           Directorio de instalación
    +-- bin                             Distribución binaria de IntyBasic
    |    |-- intbas.pl                  -> Script de ayuda para compilar/ensamblar
    |    |-- intybasic_linux            -> IntyBasic para Linux
    |    |-- IntyBASIC.exe              -> IntyBasic para Windows
    |    |-- intybasic                  -> IntyBasic para Mac OSX
    |    |-- intycolor                  -> IntyColor para Mac OSX
    |    |-- intyColor.exe              -> IntyColor para Windows
    |    `-- intycolor_linux            -> IntyColor para Linux
    |
    +-- examples                        Repositorio de ejemplos de IntyBASIC
    |    +-- game1                      Proyecto de ejemplo: game1
    |    |    +-- bin                   Salida ensamblador de AS-1600
    |    |    |    |-- game1.bin        \_ Binario del juego en formato BIN+CFG
    |    |    |    |-- game1.cfg        /
    |    |    |    |-- game1.ls         -> Archivo de listado ensamblador
    |    |    |    |-- game1.map        -> Mapa de memoria ensamblador
    |    |    |    |-- game1.rom        -> Binario del juego en formato ROM
    |    |    |    `-- game1.sym        -> Tabla de símbolos ensamblador
    |    |    |
    |    |    +-- asm                   Salida del compilador IntyBASIC
    |    |    |    `-- game1.asm        -> Código ensamblador generado
    |    |    |
    |    |    `-- game1.bas             Código fuente BASIC
    |    |
    |    `-- title
    |        +-- bin                    Salida ensamblador de AS-1600
    |        |    |-- title.bin         \_ Binario del juego en formato BIN+CFG
    |        |    |-- title.cfg         /
    |        |    |-- title.ls          -> Archivo de listado ensamblador
    |        |    |-- title.map         -> Mapa de memoria ensamblador
    |        |    |-- title.rom         -> Binario del juego en formato ROM
    |        |    `-- title.sym         -> Tabla de símbolos ensamblador
    |        |
    |        +-- asm                    Salida del compilador IntyBasic
    |        |    `-- title.asm         -> Código ensamblador generado
    |        |
    |        `-- title.bas              Código fuente BASIC
    |
    +-- games                           Repositorio de programas de juegos BASIC
    |   `-- (empty)                     Agregue sus propios programas aquí.
    |
    +-- lib                             Módulos de librería de IntyBasic
    |    |-- intybasic_prologue.asm     -> Módulo prólogo
    |    `-- intybasic_epilogue.asm     -> Módulo epílogo
    |
    |-- manual.txt                      Manual de IntyBASIC
    `-- INTBAS - README.txt             Este archivo README.

Necesita asignar algunas variables de environment:

  INTV_SDK_PATH    =  Apunta al directorio conteniendo la estructura de jzintv
  INTV_BASIC_PATH  =  Apunta al directorio de instalación (vea la estructura)

DZ-Jay ha montado su propia distribución IntyBASIC siguiendo esa estructura:

  http://atariage.com/forums/index.php?app=core&module=attach&section=attach&attach_id=363028


>>>>>>>>>>>>>>  Enlaces útiles

Emulador jzintv (incluye ensamblador as1600)

  http://spatula-city.org/~im14u2c/intv/

Emulador Intellivision Nostalgia

  http://www.intellivision.us/intvgames/nostalgia/nostalgia.php
  
  
>>>>>>>>>>>>>>  Reconocimientos

Gracias a los siguientes miembros de AtariAge por contribuir sugerencias valiosas,
programas de prueba e incluso librerías de apoyo:

  Albert 
  artrag
  atari2600land
  awhite2600
  carlsson
  catsfolly
  ckblackm
  CrazyBoss
  Cybearg
  DZ-Jay
  First Spear
  freewheel
  GroovyBee
  intvnut
  Jess Ragan
  Kiwi
  RevEng
  SpiceWare
  Tarzilla
