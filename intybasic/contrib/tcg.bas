REM *************************************************************************
REM IntyBASIC Project: tcg
REM *************************************************************************
REM     Programmer: Catsfolly
REM     Created:    2015/7/16
REM     Updated:    2015/8/11
REM
REM     Project automatically generated by INTYNEW.
REM *************************************************************************
REM History:
REM 2015/7/16 - tcg project created.
REM *************************************************************************

REM Include useful predefined constants
INCLUDE "constants.bas"

CONST eol = 255
CONST top_border 	= (204 * 8)
CONST bottom_border 	= (207 * 8)
CONST left_border 	= (194 * 8)
CONST right_border	= (195 * 8)
CONST ascii_space	= (32)
CONST ascii_pound	= (35)
CONST ascii_zero	= (48)
CONST chars_in_a_line   = (18)

DEF FN ascii_to_backtab(ascii_c) = ((ascii_c - ascii_space) * 8)

dim text_buffer(200)
text_buffer_write_index = 0
#template_read_index = 0
rem init the game in colorstack mode

	MODE SCREEN_CS, STACK_BLACK, STACK_WHITE, STACK_WHITE, STACK_WHITE
	wait

rem load some gram tiles (just for the corners of the border)
	DEFINE 0,10,game_tiles

rem display the awesome title screen
    print at SCREENPOS(5, 3) color CS_BLUE, "Trollish"
    print at SCREENPOS(5, 4) color CS_RED,  "Comment"
    print at SCREENPOS(5, 5) color CS_BLUE, "Generator"

    print at SCREENPOS(1, 10) color CS_WHITE, "Press Any Key..."
    wait
tloop0:
	if cont = 0 then goto tloop0

rem any key you press is the wrong key
    cls
	print at SCREENPOS(3,5) color CS_WHITE, "Not THAT key!"
	for i = 0 to 60
	   wait
	next i
	goto do_stuff

rem main loop
tloop:
	if cont = 0 then goto tloop

do_stuff:
    gosub draw_border

	text_buffer_write_index = 0	
	#template_read_index = 0

rem choose a template
	zeros_to_find = RAND AND $0003
template_find_zeros_loop:
	if (zeros_to_find = 0) then goto template_ready
template_l2:	
	#test = s1(#template_read_index)
	if (#test <> 0) then #template_read_index = #template_read_index + 1 : goto template_l2
	zeros_to_find = zeros_to_find - 1
	#template_read_index = #template_read_index + 1 ' skip the zero
	goto template_find_zeros_loop

template_ready:
write_loop:

	#temp = s1(#template_read_index)
	
	rem if we find a pound character in the template, call add_variable to replace it with a randomly chosen word or phrase.
	if #temp = ascii_pound then var_type = s1(#template_read_index+1) - ascii_zero : #template_read_index = #template_read_index + 2 : #temp = s1(#template_read_index) : gosub add_variable

	text_buffer(text_buffer_write_index) = #temp
	if #temp = 0 then goto do_output
	#template_read_index = #template_read_index+1
	text_buffer_write_index = text_buffer_write_index+1
	goto write_loop

rem output the buffer to the display, going to the next line to avoid splitting up words

do_output:
	text_buffer_read_index = 0
	current_backtab_offset = 21
        nw_start = 0
        nw_end = 0
        
        chars_left = chars_in_a_line
output_loop:
	gosub find_next_word

        if nw_start = EOL then goto done111
	next_word_length = nw_end - nw_start + 1
	if (next_word_length) > chars_in_a_line then goto done111

	rem if this word won't fit into the remaining spaces on the current line, then move down to the next line
	if (next_word_length > chars_left) then current_backtab_offset = current_backtab_offset + chars_left +(BACKGROUND_COLUMNS - chars_in_a_line) : chars_left = chars_in_a_line
	rem copy the next word to backtab (the screen)
	for idx = nw_start to nw_end
		#temp = text_buffer(idx)
		#temp = ascii_to_backtab(#temp)
    		poke BACKTAB + current_backtab_offset, #temp + #text_color
		current_backtab_offset = current_backtab_offset + 1
		wait 
		wait
		wait
	next idx
	text_buffer_read_index = nw_end+1
	chars_left = chars_left - (next_word_length)
	if chars_left > 1 then current_backtab_offset = current_backtab_offset + 1 : chars_left = chars_left -1
	goto output_loop

done111:
	
	wait
	goto tloop

endlessloop:
    goto endlessloop

REM *******************************************
REM
REM draw_border
REM
REM (adapted from the snake game)
REM
REM *******************************************

draw_border: procedure
	#text_color = tcolors(RAND AND 7)	

	cls ' clear the screen

 	for i = 1 to 18 
 		poke screenaddr(i, 0),top_border     + #text_color ' draw the top    border
		poke screenaddr(i,11),bottom_border  + #text_color ' draw the bottom border
	next i
	for i = 1 to 10
		poke screenaddr( 0, i),left_border   + #text_color ' draw the left  border
		poke screenaddr(19, i),right_border  + #text_color ' draw the right border
	next i

	rem draw the custom characters for each corner
	poke screenaddr( 0, 0), BG00 + #text_color
	poke screenaddr(19, 0), BG01 + #text_color
	poke screenaddr( 0,11), BG02 + #text_color
	poke screenaddr(19,11), BG03 + #text_color
		
end


REM *****************************************************************
REM
REM find_next_word
REM
REM finds the start and end of the next word in the text buffer
REM input - text_buffer, text_buffer_read_index
REM output - nw_start, nw_end (indexes into the text_buffer)
REM
REM
REM *****************************************************************
find_next_word: procedure
	nw_start = eol
	nw_end = 0
	test_pos = text_buffer_read_index
fnw_loop:
	#temp = text_buffer(test_pos)
	if (#temp = 0) then goto dnw_fin
	if (#temp = ascii_space) then test_pos = test_pos +1 : goto fnw_loop
	rem found a non space character
	nw_start = test_pos

fnw_loop2:
	#temp = text_buffer(test_pos)
	if (#temp = 0) then nw_end = test_pos - 1 : goto dnw_fin
	if (#temp <> ascii_space) then test_pos = test_pos +1 : goto fnw_loop2
	rem found a space character
	nw_end = test_pos -1
dnw_fin:
	  
end


REM *****************************************************************
REM
REM add_variable
REM
REM replaces the "variable" field in the template (#1, #2 etc)
REM with a randomly chosen text chunk
REM 
REM
REM
REM *****************************************************************
add_variable: procedure
#vpos = 0
rem currently each type has exactly 16 entries
rem all the strings are in one big data table

 if (var_type = 1) then  zeros_to_find = RAND AND $000f
 if (var_type = 2) then  zeros_to_find = 16 + (RAND AND $000f)
 if (var_type = 3) then  zeros_to_find = 32 + (RAND AND $000f)
 if (var_type = 4) then  zeros_to_find = 48 + (RAND AND $000f)
 if (var_type = 5) then  zeros_to_find = 64 + (RAND AND $000f)
 if (var_type = 6) then  zeros_to_find = 80 + (RAND AND $000f)

av_find_zeros_loop:
	if (zeros_to_find = 0) then goto av_ready
av_l2:	
	#test = friend_table(#vpos)
	if (#test <> 0) then #vpos = #vpos + 1 : goto av_l2

	zeros_to_find = zeros_to_find - 1
	#vpos = #vpos + 1 ' skip the zero
	goto av_find_zeros_loop

av_ready:
	#test = friend_table(#vpos)
	if #test <> 0 then text_buffer(text_buffer_write_index) = #test : text_buffer_write_index = text_buffer_write_index+1 : #vpos = #vpos+1 : goto av_ready	
end

rem data tables

friend_table:
rem type 1 - relatives and associates

	asm string "grandson"
	data 0
ft_1:
	asm string "wife"
	data 0
ft_2:
	asm string "barber"
	data 0
ft_3:
	asm string "grocer"
	data 0
ft_4:
	asm string "lawyer"
	data 0
ft_5:
	asm string "parole officer"
	data 0
ft_6:
	asm string "straitjacket repairman"
	data 0
ft_7:
	asm string "aunt"
	data 0
ft_8:
	asm string "uncle"
	data 0
ft_9:
	asm string "manicurist"
	data 0
ft_10:
	asm string "yoga coach"
	data 0
ft_11:
	asm string "piano teacher"
	data 0
ft_12:
	asm string "plumber"
	data 0
ft_13:
	asm string "evil clone"
	data 0
ft_14:
	asm string "psychologist"
	data 0
ft_15:
	asm string "bartender"
	data 0
	rem type 2 - needs
needs:
	asm string "bacon"
	data 0
	asm string "more bacon"
	data 0
	asm string "a snow level"
	data 0
	asm string "goats"
	data 0


	asm string "sharks with lasers on their heads"
	data 0
	asm string "a complete rewrite"
	data 0
	asm string "a low score contest"
	data 0
	asm string "catchup"
	data 0

	asm string "to be in a landfill somewhere"
	data 0
	asm string "birds that flap"
	data 0
	asm string "a boredom warning label"
	data 0
	asm string "electroshock therapy"
	data 0

	asm string "a reason to exist"
	data 0
	asm string "to be a lot easier"
	data 0
	asm string "zombies"
	data 0
	asm string "the running man"
	data 0
	rem type #3 - adjectives
adj:
	asm string "angry"
	data 0
	asm string "nazi"
	data 0
	asm string "alien"
	data 0
	asm string "lovesick"
	data 0

	asm string "amish"
	data 0
	asm string "radioactive"
	data 0
	asm string "coleco-loving"
	data 0
	asm string "stoned"
	data 0

	asm string "constipated"
	data 0
	asm string "atari fanboy"
	data 0
	asm string "sight challenged"
	data 0
	asm string "robotic"
	data 0

	asm string "morbid"
	data 0
	asm string "maniacal"
	data 0
	asm string "highly questionable"
	data 0
	asm string "forgetful"
	data 0

	rem type #4 - bad designers

bad_designers:
	asm string "monkeys"
	data 0
	asm string "amoebas"
	data 0
	asm string "Martha Stewart fans"
	data 0
	asm string "RCA Studio 2 programmers"
	data 0

	asm string "IRS agents"
	data 0
	asm string "Kindergarten dropouts"
	data 0
	asm string "nuns"
	data 0
	asm string "brain donors"
	data 0

	asm string "schools of fish"
	data 0
	asm string "poodles"
	data 0
	asm string "political committees"
	data 0
	asm string "insurance salesmen"
	data 0

	asm string "certifiable accountants"
	data 0
	asm string "lawn bowling hooligans"
	data 0
	asm string "pastry chefs"
	data 0
	asm string "popsicle stick collectors"
	data 0

	rem type #5 - how they play the game
frequency:
	asm string "every day"
	data 0
	asm string "once a year"
	data 0
	asm string "before work"
	data 0
	asm string "while driving"
	data 0

	asm string "under water"
	data 0
	asm string "in the shower"
	data 0
	asm string "without using thumbs"
	data 0
	asm string "against the cat. The cat wins"
	data 0

	asm string "religiously"
	data 0
	asm string "to unwind"
	data 0
	asm string "upside down"
	data 0
	asm string "before breakfast"
	data 0

	asm string "for 5 hours a day"
	data 0
	asm string "but hates it"
	data 0
	asm string "on a gameboy based emulator"
	data 0
	asm string "and cries at the ending"
	data 0

	rem #6 - how do they react to the game
reactions:
        asm string "loves"
	data 0
	asm string "hates"
	data 0
	asm string "worships"
	data 0
	asm string "sucks at "
	data 0

	asm string "can't understand"
	data 0
	asm string "easily beats"
	data 0
	asm string "only likes the overlay of"
	data 0
	asm string "always whistles the music from"
	data 0

	asm string "falls asleep playing"
	data 0
	asm string "screams at"
	data 0
	asm string "never wants to play"
	data 0
	asm string "pretends to like"
	data 0

	asm string "stole"
	data 0
	asm string "hacked"
	data 0
	asm string "doesn't remember"
	data 0
	asm string "cheats at"
	data 0










	data 0,0,0,0

	rem the templates (only 4, should be more…)

s1:
	asm string "My #1 says this game needs #2!"
	data 0

s2:
	asm string "My #1 says this game looks like it was designed by #3 #4!"
	data 0

s3:	
	asm string "My #1 plays this game #5!"
	data 0
s4:
	asm string "My #1 #6 this game!"
	data 0

tcolors:
	data CS_BLUE
	data CS_RED
	data CS_TAN
	data CS_GREEN

	data CS_YELLOW
	data CS_WHITE
	data CS_BLUE
	data CS_WHITE
	

game_tiles:

REM 0

	BITMAP "   #####"
	BITMAP "   #    "
	BITMAP "   #    "
	BITMAP "   #    "
	
	BITMAP "   #    "
	BITMAP "   #    "
	BITMAP "   #    "
	BITMAP "   #    "

REM 1

	BITMAP "#####   "
	BITMAP "    #   "
	BITMAP "    #   "
	BITMAP "    #   "
	
	BITMAP "    #   "
	BITMAP "    #   "
	BITMAP "    #   "
	BITMAP "    #   "

REM 2

	BITMAP "   #    "
	BITMAP "   #    "
	BITMAP "   #    "
	
	BITMAP "   #    "
	BITMAP "   #    "
	BITMAP "   #    "
	BITMAP "   #    "
	BITMAP "   #####"

REM 3

	BITMAP "    #   "
	BITMAP "    #   "
	BITMAP "    #   "
	
	BITMAP "    #   "
	BITMAP "    #   "
	BITMAP "    #   "
	BITMAP "    #   "
	BITMAP "#####   "
	
